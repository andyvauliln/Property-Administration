{% extends "_base_no_sidebar.html" %}
{% load slippers %}
{% load custom_filters %}
{% block content %}

  <section class="bg-white dark:bg-gray-900"> 
    <div class="pb-8 px-4 mx-auto max-w-screen-xl lg:pb-16 lg:px-6">
        <div class="mx-auto max-w-screen-md mb-8 lg:mb-12 flex justify-center items-center flex-col">
            <h2 class="mt-4 text-4xl tracking-tight font-extrabold text-gray-900 dark:text-white mr-4">Handyman Calendar</h2>
        </div>
   
        <div class="flex-1 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {% for month, weeks in calendar_data.items %}
            {% include "handymade_calendar_comp.html" %}
            {% endfor %}
        </div>
    
    </div>
</section>


<script>
    // Wrap all initialization code in DOMContentLoaded
    document.addEventListener('DOMContentLoaded', function() {
        // Get URL parameters to check if user is admin
        const urlParams = new URLSearchParams(window.location.search);
        window.isAdmin = urlParams.get('user') === 'admin';
        window.isManager = urlParams.get('user') === 'manager';
        window.currentUser = urlParams.get('user') || 'anonymous';

        // NEW: Add storage for selected slots
        window.selectedSlots = {};
        window.hasUnsavedChanges = false;

        // Initialize localStorage for bookings if not exists
        if (!localStorage.getItem('myBookings')) {
            localStorage.setItem('myBookings', JSON.stringify([]));
        }

        // Fix JSON parsing by using a safer template variable interpolation
        const bookingsJsonStr = '{{ bookings_json|escapejs }}';
        const apartmentsJsonStr = '{{ apartments_json|escapejs }}';
        const blockedSlotsJsonStr = '{{ blocked_slots_json|escapejs }}';
        
        console.log('Raw bookings_json:', bookingsJsonStr);
        const bookingsByDate = JSON.parse(bookingsJsonStr);
        console.log(bookingsByDate, "bookingsByDate");
        
        // Parse the blocked slots list and make it globally available
        window.blockedSlotsByDate = JSON.parse(blockedSlotsJsonStr);
        console.log('Blocked slots:', window.blockedSlotsByDate);
        
        // Parse the apartments list and make it globally available
        window.apartmentsList = JSON.parse(apartmentsJsonStr);
        console.log('Available apartments:', window.apartmentsList);

        // Make these functions globally available
        window.getBookingsForDate = function(dateStr) {
            return bookingsByDate[dateStr] || [];
        }

        // Updated to use created_by from database
        window.isMyBooking = function(bookingId) {
            if (window.isAdmin || window.isManager) return true;
            
            // Find the booking in all dates
            for (const dateStr in bookingsByDate) {
                const booking = bookingsByDate[dateStr].find(b => b.id === bookingId);
                if (booking) {
                    // Check if current user created this booking
                    return booking.created_by === window.currentUser;
                }
            }
            
            return false;
        }

        // No longer needed as created_by is set on the server
        window.addMyBooking = function(bookingId) {
            // This function is kept for backward compatibility
            // but doesn't need to do anything as created_by is 
            // stored in the database
            console.log('Booking created with ID:', bookingId);
            // Nothing needed here - server stores the creator
        }
        
        // Functions for server-side blocking management
        window.getBlockedSlotsForDate = function(dateStr) {
            return window.blockedSlotsByDate[dateStr] || [];
        }
        
        window.isSlotBlocked = function(dateStr, timeSlot) {
            const blockedSlots = window.getBlockedSlotsForDate(dateStr);
            
            // Check if the entire day is blocked
            if (blockedSlots.some(slot => slot.is_full_day === true)) {
                return true;
            }
            
            // Check if this specific time slot is blocked
            return blockedSlots.some(slot => 
                !slot.is_full_day && 
                slot.time_slot === timeSlot
            );
        }
        
        window.isDayFullyBlocked = function(dateStr) {
            const blockedSlots = window.getBlockedSlotsForDate(dateStr);
            return blockedSlots.some(slot => slot.is_full_day === true);
        }
        
        window.blockSlot = async function(dateStr, timeSlot) {
            if (!window.isManager) return false;
            
            try {
                const [startTime, endTime] = timeSlot.split(' - ');
                const formData = new FormData();
                formData.append('block_slot', 'true');
                formData.append('date', dateStr);
                formData.append('start_time', startTime);
                formData.append('end_time', endTime);
                formData.append('reason', 'Blocked by manager');
                
                const response = await fetch('/handyman_calendar/?user=manager', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    // Add the new blocked slot to our in-memory representation
                    const data = await response.json();
                    if (!window.blockedSlotsByDate[dateStr]) {
                        window.blockedSlotsByDate[dateStr] = [];
                    }
                    
                    window.blockedSlotsByDate[dateStr].push({
                        id: data.id,
                        is_full_day: false,
                        start_time: startTime,
                        end_time: endTime,
                        time_slot: timeSlot,
                        reason: 'Blocked by manager',
                        created_by: 'manager'
                    });
                    
                    return true;
                } else {
                    console.error('Failed to block slot:', await response.json());
                    return false;
                }
            } catch (error) {
                console.error('Error blocking slot:', error);
                return false;
            }
        }
        
        window.unblockSlot = async function(dateStr, timeSlot) {
            if (!window.isManager) return false;
            
            try {
                const [startTime, endTime] = timeSlot.split(' - ');
                const formData = new FormData();
                formData.append('unblock_slot', 'true');
                formData.append('date', dateStr);
                formData.append('start_time', startTime);
                formData.append('end_time', endTime);
                
                const response = await fetch('/handyman_calendar/?user=manager', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    // Remove the blocked slot from our in-memory representation
                    if (window.blockedSlotsByDate[dateStr]) {
                        window.blockedSlotsByDate[dateStr] = window.blockedSlotsByDate[dateStr].filter(
                            slot => !(slot.time_slot === timeSlot || 
                                  (slot.start_time === startTime && slot.end_time === endTime))
                        );
                        
                        if (window.blockedSlotsByDate[dateStr].length === 0) {
                            delete window.blockedSlotsByDate[dateStr];
                        }
                    }
                    
                    return true;
                } else {
                    console.error('Failed to unblock slot:', await response.json());
                    return false;
                }
            } catch (error) {
                console.error('Error unblocking slot:', error);
                return false;
            }
        }
        
        window.blockEntireDay = async function(dateStr) {
            if (!window.isManager) return false;
            
            try {
                const formData = new FormData();
                formData.append('block_day', 'true');
                formData.append('date', dateStr);
                formData.append('reason', 'Entire day blocked by manager');
                
                const response = await fetch('/handyman_calendar/?user=manager', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    // Add the blocked day to our in-memory representation
                    const data = await response.json();
                    if (!window.blockedSlotsByDate[dateStr]) {
                        window.blockedSlotsByDate[dateStr] = [];
                    }
                    
                    // Delete all specific time slot blocks for this day
                    window.blockedSlotsByDate[dateStr] = window.blockedSlotsByDate[dateStr].filter(
                        slot => slot.is_full_day
                    );
                    
                    // Add the full day block
                    window.blockedSlotsByDate[dateStr].push({
                        id: data.id,
                        is_full_day: true,
                        reason: 'Entire day blocked by manager',
                        created_by: 'manager'
                    });
                    
                    return true;
                } else {
                    console.error('Failed to block day:', await response.json());
                    return false;
                }
            } catch (error) {
                console.error('Error blocking day:', error);
                return false;
            }
        }
        
        window.unblockEntireDay = async function(dateStr) {
            if (!window.isManager) return false;
            
            try {
                const formData = new FormData();
                formData.append('unblock_day', 'true');
                formData.append('date', dateStr);
                
                const response = await fetch('/handyman_calendar/?user=manager', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    // Remove this day from our in-memory blocked slots
                    delete window.blockedSlotsByDate[dateStr];
                    return true;
                } else {
                    console.error('Failed to unblock day:', await response.json());
                    return false;
                }
            } catch (error) {
                console.error('Error unblocking day:', error);
                return false;
            }
        }

        // Make other functions globally available
        window.openModalForDay = openModalForDay;
        window.generateTimeSlots = generateTimeSlots;
        window.createBookingRow = createBookingRow;
        window.closeModal = closeModal;
        window.showValidationErrors = showValidationErrors;
        window.clearValidationErrors = clearValidationErrors;
        window.handleSubmitBooking = handleSubmitBooking;
        window.handleDeleteBooking = handleDeleteBooking;
    });

    // Keep these function definitions outside the DOMContentLoaded event
    // because they're referenced by the HTML
    function generateTimeSlots() {
        const slots = [];
        const startHour = 9;
        const endHour = 17;
        for (let hour = startHour; hour < endHour; hour++) {
            // First 30 minutes of the hour
            const startTime1 = `${hour.toString().padStart(2, '0')}:00`;
            const endTime1 = `${hour.toString().padStart(2, '0')}:30`;
            slots.push({ start: startTime1, end: endTime1 });
            
            // Second 30 minutes of the hour
            const startTime2 = `${hour.toString().padStart(2, '0')}:30`;
            const endTime2 = `${(hour + 1).toString().padStart(2, '0')}:00`;
            slots.push({ start: startTime2, end: endTime2 });
        }
        return slots;
    }

    function createBookingRow(booking = null) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'flex flex-col space-y-2 p-2 border rounded hover:bg-gray-50 ml-4';
        
        const isNewRow = !booking;
        const inputClass = 'px-2 py-1 border rounded w-full focus:border-blue-500 focus:ring-1 focus:ring-blue-500';
        
        const timeSlots = generateTimeSlots();
        const timeOptions = timeSlots.map(slot => {
            const optionClass = '';
            const isSelected = booking && booking.start_time === slot.start && booking.end_time === slot.end ? 'selected' : '';
            return `<option value="${slot.start} - ${slot.end}" ${isSelected}>${slot.start} - ${slot.end}</option>`;
        }).join('');

        rowDiv.innerHTML = `
            <form onsubmit="handleSubmitBooking(event)" action="/handyman_calendar/" class="flex flex-col space-y-2 w-full" 
                name="${isNewRow ? 'add' : 'edit'}">
                <input type="hidden" name="${isNewRow ? 'add' : 'edit'}" value="true">
                <input type="hidden" name="date" value="${booking?.date || ''}">
                <input type="hidden" name="id" value="${booking?.id || ''}">
                <div class="flex flex-col md:flex-row md:space-x-4 space-y-2 md:space-y-0 md:space-x-4">
                    <div class="flex-grow space-y-2">
                        <div class="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-4">
                            <input type="text" name="apartment_name" 
                                placeholder="Apartment" 
                                value="${booking?.apartment_name || ''}" 
                                class="${inputClass} md:w-[150px] w-full">
                                
                            <input type="text" name="tenant_name" 
                                placeholder="Tenant Name" 
                                value="${booking?.tenant_name || ''}" 
                                class="${inputClass} md:flex-1 w-full">
                                
                            <input type="tel" name="tenant_phone" 
                                placeholder="Phone" 
                                value="${booking?.tenant_phone || ''}" 
                                class="${inputClass} md:w-[200px] w-full">
                                
                            <div class="flex space-x-2">
                                <input type="text" name="start_time" 
                                    readonly
                                    placeholder="Time Slot" 
                                    value="${booking ? `${booking.start_time} - ${booking.end_time}` : ''}" 
                                    class="${inputClass} w-full md:w-[150px] bg-gray-50 cursor-not-allowed">
                            </div>
                        </div>
                        <div class="w-full">
                            <input type="text" name="notes" 
                                placeholder="Notes" 
                                value="${booking?.notes || ''}" 
                                class="${inputClass}">
                        </div>
                    </div>
                    
                    <div class="flex md:flex-col justify-end md:justify-center space-x-2 md:space-x-0 md:space-y-2">
                        <button type="submit" 
                            class="pl-1 rounded-full hover:bg-blue-100 text-blue-600" 
                            title="Save">
                            <svg fill="blue" version="1.1" id="Capa_1" class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 407.096 407.096" xml:space="preserve"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <path d="M402.115,84.008L323.088,4.981C319.899,1.792,315.574,0,311.063,0H17.005C7.613,0,0,7.614,0,17.005v373.086 c0,9.392,7.613,17.005,17.005,17.005h373.086c9.392,0,17.005-7.613,17.005-17.005V96.032 C407.096,91.523,405.305,87.197,402.115,84.008z M300.664,163.567H67.129V38.862h233.535V163.567z"></path> <path d="M214.051,148.16h43.08c3.131,0,5.668-2.538,5.668-5.669V59.584c0-3.13-2.537-5.668-5.668-5.668h-43.08 c-3.131,0-5.668,2.538-5.668,5.668v82.907C208.383,145.622,210.92,148.16,214.051,148.16z"></path> </g> </g> </g></svg>
                        </button>
                        ${booking ? `
                            <button type="button" onclick="handleDeleteBooking(${booking.id})" 
                                class="pt-1 rounded-full hover:bg-red-100 text-red-600"
                                title="Delete">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        ` : ''}
                    </div>
                </div>
            </form>
        `;
        
        return rowDiv;
    }

    function closeModal() {
        document.getElementById('bookingsModal').classList.add('hidden');
        clearValidationErrors();
    }

    function showValidationErrors(errors) {
        const container = document.getElementById('validationMessages');
        const messagesList = document.getElementById('validationMessagesList');
        messagesList.innerHTML = '';
        
        console.log('Validation errors received:', errors);
        
        // Add a fallback if no errors are visible
        let errorDisplayed = false;
        
        if (Array.isArray(errors)) {
            errors.forEach(error => {
                const errorItem = document.createElement('div');
                errorItem.className = 'mt-1';
                errorItem.textContent = `• ${error}`;
                messagesList.appendChild(errorItem);
                errorDisplayed = true;
            });
        } else if (typeof errors === 'object' && errors !== null) {
            // Handle error object (likely from server validation)
            if (errors.error && typeof errors.error === 'object') {
                // Process form field errors
                Object.entries(errors.error).forEach(([field, fieldErrors]) => {
                    if (Array.isArray(fieldErrors)) {
                        fieldErrors.forEach(error => {
                            const errorItem = document.createElement('div');
                            errorItem.className = 'mt-1';
                            errorItem.textContent = `• ${field}: ${error}`;
                            messagesList.appendChild(errorItem);
                            errorDisplayed = true;
                        });
                    } else {
                        const errorItem = document.createElement('div');
                        errorItem.className = 'mt-1';
                        errorItem.textContent = `• ${field}: ${fieldErrors}`;
                        messagesList.appendChild(errorItem);
                        errorDisplayed = true;
                    }
                });
            } else {
                // Display error message or stringified object if no better representation
                const errorMessage = errors.error || JSON.stringify(errors);
                const errorItem = document.createElement('div');
                errorItem.className = 'mt-1';
                errorItem.textContent = `• ${errorMessage}`;
                messagesList.appendChild(errorItem);
                errorDisplayed = true;
            }
        } else {
            const errorItem = document.createElement('div');
            errorItem.className = 'mt-1';
            errorItem.textContent = `• ${errors}`;
            messagesList.appendChild(errorItem);
            errorDisplayed = true;
        }
        
        // If no specific errors were displayed, show a generic message
        if (!errorDisplayed) {
            const errorItem = document.createElement('div');
            errorItem.className = 'mt-1';
            errorItem.textContent = `• Unable to process your request. Please check all fields and try again.`;
            messagesList.appendChild(errorItem);
        }
        
        container.classList.remove('hidden');
    }

    function clearValidationErrors() {
        const container = document.getElementById('validationMessages');
        container.classList.add('hidden');
        const messagesList = document.getElementById('validationMessagesList');
        messagesList.innerHTML = '';
    }

    async function handleSubmitBooking(event) {
        event.preventDefault();
        clearValidationErrors();
        
        const form = event.target;
        const formData = new FormData(form);
        const errors = [];
        
        // Validate required fields
        const required_fields = {
            'apartment_name': formData.get('apartment_name'),
            'tenant_name': formData.get('tenant_name'),
            'tenant_phone': formData.get('tenant_phone'),
            'start_time': formData.get('start_time') // Only need to check start_time as it represents the slot
        };

        const missing_fields = Object.entries(required_fields)
            .filter(([_, value]) => !value)
            .map(([field, _]) => field.replace('_', ' '));

        if (missing_fields.length > 0) {
            errors.push(`The following fields are required: ${missing_fields.join(', ')}`);
        }

        // Validate apartment name exists in the list
        const apartmentName = formData.get('apartment_name');
        if (apartmentName) {
            if (!apartmentsList.includes(apartmentName)) {
                // Find similar apartment names (containing the input)
                const suggestions = apartmentsList.filter(apt => 
                    apt.toLowerCase().includes(apartmentName.toLowerCase())
                );
                
                if (suggestions.length > 0) {
                    errors.push(`Did you mean: ${suggestions.join(', ')}?`);
                } else {
                    errors.push("This apartment number doesn't exist. Please ask the manager for the correct apartment number.");
                }
            }
        }

        // Get the raw date value
        const rawDate = document.getElementById('modalDate').getAttribute('data-date');
        formData.set('date', rawDate);

        // Extract start and end times from the selected slot
        const selectedSlot = formData.get('start_time');
        const [startTime, endTime] = selectedSlot.split(' - ');
        console.log(startTime, endTime,selectedSlot, "startTime, endTime,selectedSlot");

        // Check if slot is blocked by manager
        if (window.isSlotBlocked(rawDate, selectedSlot)) {
            errors.push('This time slot has been blocked by the manager and is not available for booking.');
        }

        // Ensure times are in HH:MM format
        const formatTime = time => time.padStart(5, '0');
        formData.set('start_time', formatTime(startTime));
        formData.set('end_time', formatTime(endTime));

        // Check if date is in the past
        const selectedDate = new Date(rawDate);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        

        // Check for overlapping appointments
        const existingBookings = getBookingsForDate(rawDate);
        const currentBookingId = formData.get('id');
        const hasOverlap = existingBookings.some(booking => {
            if (booking.id === currentBookingId) return false;
            
            return !(
                booking.end_time <= startTime ||
                booking.start_time >= endTime
            ) && booking.apartment_name === formData.get('apartment_name');
        });

        if (hasOverlap) {
            errors.push(`There is already an appointment scheduled for ${formData.get('apartment_name')} on ${rawDate} during this time period`);
        }

        if (errors.length > 0) {
            showValidationErrors(errors);
            return;
        }
        
        try {
            // Log the form data being sent for debugging
            const formDataObj = {};
            formData.forEach((value, key) => {
                formDataObj[key] = value;
            });
            console.log('Submitting form data:', formDataObj);

            const response = await fetch('/handyman_calendar/', {
                method: 'POST',
                body: formData
            });

            const responseText = await response.text();
            console.log('Raw response:', responseText);
            
            let data;
            try {
                data = JSON.parse(responseText);
                console.log('Parsed response data:', data);
            } catch (e) {
                console.error('Error parsing JSON response:', e);
                showValidationErrors('Server returned invalid response format');
                return;
            }

            if (response.ok) {
                if (data.id) {
                    addMyBooking(data.id);
                }
                clearValidationErrors();
                form.reset();
                closeModal();
                window.location.reload();
            } else {
                if (data.error) {
                    // Try to log and display the specific error
                    console.error('Server validation error:', data.error);
                    
                    if (typeof data.error === 'string') {
                        showValidationErrors(data.error);
                    } else if (typeof data.error === 'object') {
                        // Check if it's an empty object
                        if (Object.keys(data.error).length === 0) {
                            showValidationErrors('Server validation failed. Please check all form fields and try again.');
                        } else {
                            // Create an array of error messages from the error object
                            const errorMessages = [];
                            Object.entries(data.error).forEach(([field, message]) => {
                                errorMessages.push(`${field}: ${message}`);
                            });
                            showValidationErrors(errorMessages);
                        }
                    } else {
                        showValidationErrors(data);
                    }
                } else {
                    showValidationErrors('Server error: ' + (data.message || 'Unknown error'));
                }
            }
        } catch (error) {
            console.error('Request error:', error);
            showValidationErrors('Failed to communicate with the server: ' + error.message);
        }
    }

    async function handleDeleteBooking(bookingId) {
        if (!isMyBooking(bookingId)) {
            showValidationErrors("You can only delete your own bookings");
            return;
        }

        if (confirm('Are you sure you want to delete this booking?')) {
            const formData = new FormData();
            formData.set('delete', 'true');
            formData.set('id', bookingId);
            
            try {
                const response = await fetch('/handyman_calendar/', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    clearValidationErrors();
                    closeModal();
                    window.location.reload();
                } else {
                    const data = await response.json();
                    showValidationErrors(data.error || 'Failed to delete booking');
                }
            } catch (error) {
                console.error('Error:', error);
                showValidationErrors('Failed to delete booking');
            }
        }
    }

    // Close modal when clicking outside
    document.addEventListener('click', function(event) {
        const modal = document.getElementById('bookingsModal');
        const modalContent = modal.querySelector('div');
        if (event.target === modal) {
            closeModal();
        }
    });


    // Helper function to get booking data by ID
    function getBookingById(bookingId) {
        const date = document.getElementById('modalDate').getAttribute('data-date');
        const bookings = getBookingsForDate(date);
        return bookings.find(booking => booking.id === bookingId);
    }

    // Move all popover-related code inside DOMContentLoaded
    document.addEventListener('DOMContentLoaded', function() {
        // Add event listener for close button
        const closePopoverButton = document.getElementById('close-popover');
        if (closePopoverButton) {
            closePopoverButton.addEventListener('click', hidePopover);
        }

        // Prevent popover from closing when clicking inside it
        const dynamicPopover = document.getElementById('dynamic-popover');
        if (dynamicPopover) {
            dynamicPopover.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
            });
        }

        // Initialize popover listeners
        addPopoverListeners();
    });

    // Keep these functions outside but available globally
    function showPopover(event, dateStr) {
        const bookings = getBookingsForDate(dateStr);
        const blockedSlots = getBlockedSlotsForDate(dateStr);
        const isFullDayBlocked = isDayFullyBlocked(dateStr);
        
        // Only show popover if there are bookings or blocked slots
        if (!bookings || (bookings.length === 0 && blockedSlots.length === 0)) return;

        const popover = document.getElementById('dynamic-popover');
        const title = document.getElementById('popover-title');
        const content = document.getElementById('popover-content');

        if (!popover || !title || !content) return;

        // Create a date object at noon UTC to avoid timezone issues
        const [year, month, dayOfMonth] = dateStr.split('-').map(Number);
        const date = new Date(Date.UTC(year, month - 1, dayOfMonth, 12, 0, 0));
        
        title.textContent = new Intl.DateTimeFormat('en-US', { 
            month: 'long', 
            day: 'numeric',
            year: 'numeric',
            timeZone: 'UTC'  // Ensure consistent timezone handling
        }).format(date);

        if (isFullDayBlocked) {
            content.innerHTML = `<div class="py-1 bg-gray-300">
                <div class="text-gray-700 font-semibold">
                    Entire day blocked by manager
                </div>
            </div>`;
            
            // Position popover
            popover.style.left = `${event.pageX + 10}px`;
            popover.style.top = `${event.pageY + 10}px`;
            popover.classList.remove('hidden');
            return;
        }

        // Generate content - show all time slots and mark booked and blocked ones
        content.innerHTML = generateTimeSlots().map(slot => {
            const timeSlotStr = `${slot.start} - ${slot.end}`;
            const existingBooking = bookings.find(booking => 
                booking.start_time === slot.start && booking.end_time === slot.end
            );
            const isBooked = existingBooking !== undefined;
            const isMyBookingSlot = existingBooking ? window.isMyBooking(existingBooking.id) : false;
            const isBlocked = window.isSlotBlocked(dateStr, timeSlotStr);
            
            let slotClass = '';
            let statusText = '';
            
            if (isBlocked) {
                slotClass = 'bg-gray-300';
                statusText = '(Blocked by Manager)';
            } else if (isBooked) {
                slotClass = 'bg-red-200';
                statusText = isMyBookingSlot ? '(Booked)(User Booking)' : '(Booked)';
            } else {
                slotClass = 'bg-green-200';
                statusText = '(Available)';
            }
            
            return `
                <div class="py-1 ${slotClass}">
                    <div class="text-gray-700">
                        ${slot.start} - ${slot.end} ${statusText}
                    </div>
                </div>
            `;
        }).join('');

        // Position popover
        popover.style.left = `${event.pageX + 10}px`;
        popover.style.top = `${event.pageY + 10}px`;
        popover.classList.remove('hidden');
    }

    function hidePopover() {
        const popover = document.getElementById('dynamic-popover');
        if (popover) {
            popover.classList.add('hidden');
        }
    }

    function addPopoverListeners() {
        const bookedDays = document.querySelectorAll('[data-has-bookings="true"], [data-fully-blocked="true"]');
        bookedDays.forEach(day => {
            day.addEventListener('mouseenter', (e) => {
                const dateStr = day.getAttribute('data-date');
                showPopover(e, dateStr);
            });
            day.addEventListener('mouseleave', hidePopover);
        });
    }

    // Keep these function definitions outside the DOMContentLoaded event
    function openModalForDay(day) {
        clearValidationErrors();
        const bookings = getBookingsForDate(day);
        const blockedSlots = getBlockedSlotsForDate(day);
        const isFullDayBlocked = isDayFullyBlocked(day);
        const modal = document.getElementById('bookingsModal');
        const modalDate = document.getElementById('modalDate');
        const bookingsList = document.getElementById('bookingsList');
        
        // Initialize slot selection tracking for this day
        window.selectedSlots[day] = window.selectedSlots[day] || {
            toBlock: [],
            toUnblock: []
        };
        window.hasUnsavedChanges = false;
        
        modalDate.setAttribute('data-date', day);
        
        // Create a date object at noon UTC to avoid timezone issues
        const [year, month, dayOfMonth] = day.split('-').map(Number);
        const dateObj = new Date(Date.UTC(year, month - 1, dayOfMonth, 12, 0, 0));
        
        const formattedDate = new Intl.DateTimeFormat('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            timeZone: 'UTC'  // Ensure consistent timezone handling
        }).format(dateObj);
        
        modalDate.textContent = formattedDate;
        bookingsList.innerHTML = '';
        
        // Add manager controls if user is manager
        if (window.isManager) {
            const managerControls = document.createElement('div');
            managerControls.className = 'flex justify-between items-center mb-4 p-3 bg-blue-50 rounded-lg';
            
            const controlsTitle = document.createElement('h4');
            controlsTitle.className = 'text-lg font-medium text-blue-800';
            controlsTitle.textContent = 'Manager Controls';
            
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'flex space-x-3';
            
            const selectAllBtn = document.createElement('button');
            selectAllBtn.className = 'px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition';
            selectAllBtn.textContent = 'Select All Slots';
            selectAllBtn.setAttribute('data-selected', 'false');
            selectAllBtn.onclick = function() {
                const isSelected = this.getAttribute('data-selected') === 'true';
                const timeSlots = document.querySelectorAll('[data-time-slot]');
                
                if (isSelected) {
                    // Deselect all slots
                    timeSlots.forEach(slotDiv => {
                        const checkbox = slotDiv.querySelector('input[type="checkbox"]');
                        if (checkbox && checkbox.checked) {
                            checkbox.checked = false;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });
                    this.textContent = 'Select All Slots';
                    this.setAttribute('data-selected', 'false');
                } else {
                    // Select all slots
                    timeSlots.forEach(slotDiv => {
                        const checkbox = slotDiv.querySelector('input[type="checkbox"]');
                        if (checkbox && !checkbox.checked) {
                            checkbox.checked = true;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    });
                    this.textContent = 'Deselect All Slots';
                    this.setAttribute('data-selected', 'true');
                }
                
                // Update save button
                window.hasUnsavedChanges = window.selectedSlots[day].toBlock.length > 0 || window.selectedSlots[day].toUnblock.length > 0;
                updateSaveButton(day);
            };
            
            buttonsContainer.appendChild(selectAllBtn);
            
            managerControls.appendChild(controlsTitle);
            managerControls.appendChild(buttonsContainer);
            
            bookingsList.appendChild(managerControls);
        }
        
        // If the whole day is blocked, show message and only allow unblocking
        if (isFullDayBlocked && !window.isManager) {
            const blockedDayMessage = document.createElement('div');
            blockedDayMessage.className = 'p-4 bg-gray-200 rounded-lg text-center mb-4';
            blockedDayMessage.innerHTML = `
                <h3 class="text-xl font-semibold text-gray-700">Day Unavailable</h3>
                <p class="text-gray-600 mt-2">This entire day has been blocked by the manager and is not available for bookings.</p>
            `;
            bookingsList.appendChild(blockedDayMessage);
            modal.classList.remove('hidden');
            return;
        }
        
        // Create form container for all bookings
        const formContainer = document.createElement('form');
        formContainer.onsubmit = handleSubmitBooking;
        formContainer.className = 'space-y-4';

        // Display all time slots and mark booked ones
        const timeSlots = generateTimeSlots();
        timeSlots.forEach(slot => {
            const timeSlotStr = `${slot.start} - ${slot.end}`;
            const existingBooking = bookings.find(booking => 
                booking.start_time === slot.start && booking.end_time === slot.end
            );
            const isBooked = existingBooking !== undefined;
            const isMyBookingSlot = existingBooking ? window.isMyBooking(existingBooking.id) : false;
            const isBlocked = window.isSlotBlocked(day, timeSlotStr);
            
            let slotClass = '';
            if (isBlocked) {
                slotClass = 'bg-gray-300 cursor-not-allowed';
            } else if (isBooked) {
                slotClass = 'bg-red-200 cursor-pointer hover:bg-red-300';
            } else {
                slotClass = 'bg-green-200 cursor-pointer hover:bg-green-300';
            }
            
            // Check if this slot is selected for change
            const isSelectedToBlock = window.selectedSlots[day].toBlock.includes(timeSlotStr);
            const isSelectedToUnblock = window.selectedSlots[day].toUnblock.includes(timeSlotStr);
            
            if (isSelectedToBlock) {
                slotClass = 'bg-red-400 cursor-pointer'; // Darker red for selected to block
            } else if (isSelectedToUnblock) {
                slotClass = 'bg-green-400 cursor-pointer'; // Darker green for selected to unblock
            }
            
            const slotDiv = document.createElement('div');
            slotDiv.className = `flex justify-between items-center p-2 border rounded mb-2 ${slotClass}`;
            slotDiv.setAttribute('data-time-slot', timeSlotStr);
            
            // Create the time slot display
            const timeDisplay = document.createElement('div');
            timeDisplay.className = 'text-gray-700';
            
            let statusText = '(Available)';
            if (isBlocked) {
                statusText = '(Blocked by Manager)';
            } else if (isBooked) {
                if (isMyBookingSlot) {
                    statusText = '(Booked)(User Booking)';
                } else if (window.isAdmin) {
                    statusText = '(Booked - Click to Edit)';
                } else {
                    statusText = '(Booked)';
                }
            }
            
            if (isSelectedToBlock) {
                statusText += ' (Will be blocked)';
            } else if (isSelectedToUnblock) {
                statusText += ' (Will be unblocked)';
            }
            
            timeDisplay.textContent = `${slot.start} - ${slot.end} ${statusText}`;
            slotDiv.appendChild(timeDisplay);
            
            // Add select checkbox for manager's multi-select functionality
            if (window.isManager) {
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'flex items-center';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'mr-2 h-4 w-4 text-blue-600';
                checkbox.checked = isSelectedToBlock || isSelectedToUnblock;
                
                const selectLabel = document.createElement('label');
                selectLabel.className = 'mr-3 text-sm';
                selectLabel.textContent = 'Select';
                
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        // Add to appropriate selection array
                        if (isBlocked) {
                            // Add to unblock list if not already there
                            if (!window.selectedSlots[day].toUnblock.includes(timeSlotStr)) {
                                window.selectedSlots[day].toUnblock.push(timeSlotStr);
                                // Remove from block list if present
                                window.selectedSlots[day].toBlock = window.selectedSlots[day].toBlock.filter(slot => slot !== timeSlotStr);
                            }
                        } else {
                            // Add to block list if not already there
                            if (!window.selectedSlots[day].toBlock.includes(timeSlotStr)) {
                                window.selectedSlots[day].toBlock.push(timeSlotStr);
                                // Remove from unblock list if present
                                window.selectedSlots[day].toUnblock = window.selectedSlots[day].toUnblock.filter(slot => slot !== timeSlotStr);
                            }
                        }
                    } else {
                        // Remove from both lists
                        window.selectedSlots[day].toBlock = window.selectedSlots[day].toBlock.filter(slot => slot !== timeSlotStr);
                        window.selectedSlots[day].toUnblock = window.selectedSlots[day].toUnblock.filter(slot => slot !== timeSlotStr);
                    }
                    
                    // Show save button if we have selections
                    window.hasUnsavedChanges = window.selectedSlots[day].toBlock.length > 0 || window.selectedSlots[day].toUnblock.length > 0;
                    updateSaveButton(day);
                    
                    // Update the display of this slot
                    if (this.checked) {
                        if (isBlocked) {
                            slotDiv.className = slotDiv.className.replace('bg-gray-300', 'bg-green-400');
                            timeDisplay.textContent = `${slot.start} - ${slot.end} (Blocked by Manager) (Will be unblocked)`;
                        } else {
                            slotDiv.className = slotDiv.className.replace(
                                isBooked ? 'bg-red-200' : 'bg-green-200', 
                                'bg-red-400'
                            );
                            timeDisplay.textContent = `${slot.start} - ${slot.end} ${isBooked ? '(Booked)' : '(Available)'} (Will be blocked)`;
                        }
                    } else {
                        if (isBlocked) {
                            slotDiv.className = slotDiv.className.replace('bg-green-400', 'bg-gray-300');
                            timeDisplay.textContent = `${slot.start} - ${slot.end} (Blocked by Manager)`;
                        } else {
                            slotDiv.className = slotDiv.className.replace(
                                'bg-red-400', 
                                isBooked ? 'bg-red-200' : 'bg-green-200'
                            );
                            timeDisplay.textContent = `${slot.start} - ${slot.end} ${statusText.replace(' (Will be blocked)', '')}`;
                        }
                    }
                });
                
                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(selectLabel);
                slotDiv.prepend(checkboxContainer);
            }
            
            // Move this click handler outside of the manager condition
            // If it's available (not blocked, not booked) or it's user's booking or admin, make it interactive
            if ((!isBlocked && !isBooked) || isMyBookingSlot || window.isAdmin) {
                slotDiv.onclick = (e) => {
                    // Skip if slot is blocked by manager or if clicking on checkbox
                    if (isBlocked || e.target.type === 'checkbox') return;
                    
                    // Remove any existing form for this time slot
                    const existingForm = document.querySelector(`[data-time-slot="${slot.start}-${slot.end}"]`);
                    if (existingForm && existingForm !== slotDiv) {
                        existingForm.remove();
                        return;
                    }

                    // Create booking form
                    const bookingForm = createBookingRow(existingBooking);
                    bookingForm.setAttribute('data-time-slot', `${slot.start}-${slot.end}`);
                    
                    // Set the time in the input
                    const timeInput = bookingForm.querySelector('input[name="start_time"]');
                    if (timeInput) {
                        timeInput.value = `${slot.start} - ${slot.end}`;
                    }

                    // Insert the form after this time slot
                    slotDiv.after(bookingForm);
                };
            }

            formContainer.appendChild(slotDiv);
        });

        // Add save changes button for manager
        if (window.isManager) {
            const saveButtonContainer = document.createElement('div');
            saveButtonContainer.id = 'saveButtonContainer';
            saveButtonContainer.className = 'sticky bottom-0 bg-white p-4 border-t border-gray-200 mt-4 flex justify-center';
            
            const saveButton = document.createElement('button');
            saveButton.id = 'saveChangesButton';
            saveButton.type = 'button';
            saveButton.className = 'px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition hidden';
            saveButton.textContent = 'Save Block/Unblock Changes';
            saveButton.onclick = function() {
                saveBlockChanges(day);
            };
            
            saveButtonContainer.appendChild(saveButton);
            formContainer.appendChild(saveButtonContainer);
        }

        bookingsList.appendChild(formContainer);
        modal.classList.remove('hidden');
        
        // Update the save button visibility
        updateSaveButton(day);
    }

    // Add new helper functions
    function updateSaveButton(day) {
        const saveButton = document.getElementById('saveChangesButton');
        if (!saveButton) return;
        
        if (window.hasUnsavedChanges) {
            saveButton.classList.remove('hidden');
            const totalChanges = window.selectedSlots[day].toBlock.length + window.selectedSlots[day].toUnblock.length;
            saveButton.textContent = `Save Block/Unblock Changes (${totalChanges} slot${totalChanges !== 1 ? 's' : ''})`;
        } else {
            saveButton.classList.add('hidden');
        }
    }

    async function saveBlockChanges(day) {
        // Get the slots to update
        const toBlock = window.selectedSlots[day].toBlock;
        const toUnblock = window.selectedSlots[day].toUnblock;
        
        if (toBlock.length === 0 && toUnblock.length === 0) {
            return;
        }
        
        // Show loading state
        const saveButton = document.getElementById('saveChangesButton');
        const originalText = saveButton.textContent;
        saveButton.textContent = 'Saving...';
        saveButton.disabled = true;
        
        try {
            // Process all blocking requests
            if (toBlock.length > 0) {
                const blockPromises = toBlock.map(timeSlot => window.blockSlot(day, timeSlot));
                await Promise.all(blockPromises);
            }
            
            // Process all unblocking requests
            if (toUnblock.length > 0) {
                const unblockPromises = toUnblock.map(timeSlot => window.unblockSlot(day, timeSlot));
                await Promise.all(unblockPromises);
            }
            
            // Reset selections and refresh
            window.selectedSlots[day] = { toBlock: [], toUnblock: [] };
            window.hasUnsavedChanges = false;
            
            // Show success and refresh
            saveButton.textContent = 'Saved Successfully!';
            saveButton.className = saveButton.className.replace('bg-blue-600', 'bg-green-600');
            
            // Refresh the day view after a short delay
            setTimeout(() => {
                openModalForDay(day);
            }, 1000);
            
        } catch (error) {
            console.error('Error saving block/unblock changes:', error);
            saveButton.textContent = 'Error Saving!';
            saveButton.className = saveButton.className.replace('bg-blue-600', 'bg-red-600');
            
            // Reset button after a delay
            setTimeout(() => {
                saveButton.textContent = originalText;
                saveButton.className = saveButton.className.replace('bg-red-600', 'bg-blue-600');
                saveButton.disabled = false;
            }, 2000);
        }
    }
</script>

<div id="dynamic-popover" class="hidden fixed z-10 w-[375px] text-sm text-gray-500 bg-white border border-gray-200 rounded-lg shadow-sm dark:text-gray-400 dark:border-gray-600 dark:bg-gray-800">
    <div class="px-3 py-2 bg-gray-100 border-b border-gray-200 rounded-t-lg dark:border-gray-600 dark:bg-gray-700 flex justify-between items-center">
        <h3 class="font-semibold text-gray-900 dark:text-white" id="popover-title"></h3>
        <button id="close-popover" class="text-gray-600 hover:text-gray-800 dark:text-gray-300 dark:hover:text-white">
            &times;
        </button>
    </div>
    <div class="px-3 py-2" id="popover-content">
        <!-- Content will be dynamically added here -->
    </div>
</div>
  
{% comment %} {% include "handyman_booking_create.html" %}
{% include "handyman_booking_edit.html" %} {% endcomment %}

<div id="bookingsModal" class="hidden fixed inset-0 bg-black bg-opacity-75 overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4">
    <div class="relative border shadow-lg rounded-md bg-white mx-auto my-4 w-full max-w-[1000px] max-h-[90vh] overflow-y-auto">
        <div class="flex flex-col p-3 sm:p-4 md:p-5">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold" id="modalDate"></h3>
                <button onclick="closeModal()" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button> 
            </div>
            
            <div id="bookingsList" class="mb-4 overflow-x-auto">
                <!-- Bookings form will be inserted here -->
            </div>

            <!-- Add this new validation messages container -->
            <div id="validationMessages" class="hidden mt-4 p-4 rounded-md border border-red-200 bg-red-50">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium text-red-800">There were validation errors:</h3>
                        <div class="mt-2 text-sm text-red-700" id="validationMessagesList">
                            <!-- Validation messages will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock content %}
